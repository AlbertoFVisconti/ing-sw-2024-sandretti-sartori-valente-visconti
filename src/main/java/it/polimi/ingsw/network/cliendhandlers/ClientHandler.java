package it.polimi.ingsw.network.cliendhandlers;

import it.polimi.ingsw.controller.GameController;
import it.polimi.ingsw.controller.MainController;
import it.polimi.ingsw.events.Observer;
import it.polimi.ingsw.events.messages.MessageType;
import it.polimi.ingsw.events.messages.server.ServerMessage;
import it.polimi.ingsw.events.messages.server.ServerToClientPingMessage;
import it.polimi.ingsw.network.rmi.GameControllerWrapper;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Generic client handler object.
 * A ClientHandler is a kind of Observer that sends the updates generated by the observed object
 * to the client. It also checks that the client is still online by monitoring ingoing traffic and
 * by sending ping messages if the client.
 */
public abstract class ClientHandler implements Observer {
    // when no message arrive for this period of time, a ping message is sent
    public static final long PING_MESSAGE_THRESHOLD = 2000;

    // when no message arrive for this period of time, the client is considered disconnected
    public static final long DISCONNECTION_THRESHOLD = 10000;

    // when the client has been disconnected for ths period of time, the client handler is going to be deleted
    public static final long DEFINITIVE_DISCONNECTION_THRESHOLD = 30000;

    // timestamp of the last ping message
    private long lastPingTime;
    // timestamp of the last received message
    private long lastMessageTime;

    // disconnection info
    private boolean isDisconnected;
    private long disconnectionTime;

    private String playerIdentifier;

    // reference to the controller that handles the game the client is playing
    private GameController gameController = null;

    private final Thread disconnectionChecker;
    ScheduledExecutorService disconnectionCheckerExecutor;

    /**
     * Builds a new ClientHandler.
     * <p>
     * Defines and starts the procedure that checks whether the client is online or not.
     */
    protected ClientHandler() {
        this.disconnectionChecker = new Thread(
                () -> {
                    if (!isDisconnected) {
                        long currTime = System.currentTimeMillis();

                        // checking if a long enough time elapsed since the last received message
                        if (currTime >= (lastMessageTime + PING_MESSAGE_THRESHOLD)) {
                            // checking if the client should be considered disconnected
                            if (currTime >= (lastMessageTime + DISCONNECTION_THRESHOLD)) {
                                // client is now considered disconnected
                                this.forceDisconnection();
                                this.disconnectionCheckerExecutor.close();
                            } else if (currTime >= (lastPingTime + PING_MESSAGE_THRESHOLD)) {
                                // the client shouldn't be considered disconnected yet
                                // but since they haven't been sending message for a long time
                                // a new ping message is going to be sent
                                this.sendMessage(new ServerToClientPingMessage(false));
                            }
                        }

                    } else {
                        // if the client is disconnected, this procedure can be stopped for the moment
                        this.disconnectionCheckerExecutor.close();
                    }
                }
        );

        // setup
        this.connectionSetup();
    }

    /**
     * Sets up the ClientHandler.
     * <p>
     * Resets disconnection related parameters and timers.
     * The client will be considered
     * online since the moment this method is called.
     */
    private void connectionSetup() {
        this.lastMessageTime = System.currentTimeMillis();
        this.lastPingTime = this.lastMessageTime;

        this.disconnectionTime = -1;
        this.isDisconnected = false;

        disconnectionCheckerExecutor = Executors.newSingleThreadScheduledExecutor();
        disconnectionCheckerExecutor.scheduleAtFixedRate(this.disconnectionChecker, 0, 100, TimeUnit.MILLISECONDS);
    }

    /**
     * Retrieves the player's identifier
     *
     * @return playerIdentifier that identifies the player handled by this object
     */
    public String getPlayerIdentifier() {
        return playerIdentifier;
    }

    /**
     * Sets the player's identifier.
     *
     * @param playerIdentifier playerIdentifier that identifies the player handled by this object
     */
    public void setPlayerIdentifier(String playerIdentifier) {
        this.playerIdentifier = playerIdentifier;
    }

    /**
     * Triggered when an observed object notify its subscribers.
     * If the update shouldn't be delivered to the client handled by this ClientHandler,
     * the message will be ignored.
     *
     * @param message the message that needs to be delivered to the client.
     */
    @Override
    public void onUpdate(ServerMessage message) {
        if (message.messageType == MessageType.PRIVATE_MODEL_UPDATE_MESSAGE
                && !message.getAddresseeIdentifier().equals(this.playerIdentifier)) {
            return;
        }
        this.sendMessage(message);
    }

    /**
     * Allows to send a message to the client handled by this object
     *
     * @param message ServerMessage object containing the data that needs to be sent to the client
     */
    public abstract void sendMessage(ServerMessage message);


    /**
     * Allows to provide the controller to the game the player's playing to the ClientHandler.
     *
     * @param gameControllerWrapper GameControllerWrapper that wraps the GameController of the game the client's playing
     */
    final public void setController(GameControllerWrapper gameControllerWrapper) {
        this.gameController = gameControllerWrapper.getGameController();

        // linking the controller to the ClientHandler (this procedure depends on the protocol used)
        this.linkController(gameControllerWrapper);
    }

    final public void resetController() {
        this.gameController = null;
        this.linkController(null);
    }

    /**
     * Allows to link the client handler to the game the client is playing.
     *
     * @param gameControllerWrapper the GameControllerWrapper object that contains a reference to the game the client is playing.
     */
    protected abstract void linkController(GameControllerWrapper gameControllerWrapper);


    /**
     * Returns the time elapsed since the disconnection occurred, in millisecond.
     * If the client is currently online (not disconnected), it returns 0
     *
     * @return time elapsed since disconnection in millisecond, 0 if client's online
     */
    final public long getTimeSinceDisconnection() {
        if (!this.isDisconnected) return 0;
        return System.currentTimeMillis() - this.disconnectionTime;
    }

    /**
     * Marks the client as disconnected without the need for a certain period of time to pass.
     * <p>
     * Used internally by the ClientHandler and subclasses.
     */
    protected void forceDisconnection() {
        this.isDisconnected = true;
        this.disconnectionTime = System.currentTimeMillis();
        if (gameController != null) {
            gameController.handleDisconnection(this);
        }
    }

    /**
     * Checks whether the client's disconnected or not.
     *
     * @return {@code true} if the client's disconnected, {@code false} otherwise
     */
    public boolean isDisconnected() {
        return isDisconnected;
    }

    /**
     * Allows to inform the ClientHandler that a message from the client was received
     */
    final public synchronized void messageReceived() {
        if (this.isDisconnected) {
            // a client that has previously disconnected came back online
            this.connectionSetup();

            if (gameController != null) {
                // the client was playing a game: rejoining
                String nickname = MainController.getInstance().getPlayer(this.getPlayerIdentifier()).nickName;
                this.gameController.handleReconnection(nickname, this, null);
            }
        } else {
            // resets message timers
            this.lastMessageTime = System.currentTimeMillis();
            this.lastPingTime = this.lastMessageTime;
        }
    }
}
