package it.polimi.ingsw.view;

import it.polimi.ingsw.controller.GameStatus;
import it.polimi.ingsw.controller.TurnStatus;
import it.polimi.ingsw.events.messages.server.*;
import it.polimi.ingsw.model.ScoreBoard;
import it.polimi.ingsw.model.cards.CardSlot;
import it.polimi.ingsw.model.cards.PlayCard;
import it.polimi.ingsw.model.cards.StartCard;
import it.polimi.ingsw.model.cards.corners.Resource;
import it.polimi.ingsw.model.chat.ChatMessage;
import it.polimi.ingsw.model.goals.Goal;
import it.polimi.ingsw.model.player.PlayerColor;
import it.polimi.ingsw.model.saving.ClientGameSaving;
import it.polimi.ingsw.network.Client;
import it.polimi.ingsw.network.rmi.VirtualController;
import it.polimi.ingsw.network.serverhandlers.RMIServerHandler;
import it.polimi.ingsw.network.serverhandlers.ServerHandler;
import it.polimi.ingsw.utils.CardLocation;

import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
import java.util.Set;

/**
 * Client-side remote object that receive Remote Method Invocations from the Server
 * and "transform" them into messages that will be processed by the actual View (View) asynchronously.
 */
public class ViewWrapper extends UnicastRemoteObject implements VirtualView {
    // wrapper view
    View view;

    /**
     * Builds a new ViewWrapper remote object that wraps the provided view.
     *
     * @param view the View that needs to be wrapped. Usually the local View is unique.
     * @throws RemoteException if an error occurs during remote communication
     */
    public ViewWrapper(View view) throws RemoteException {
        super();
        this.view = view;
    }

    /**
     * Provides (synchronously) a reference to the remote VirtualController Object
     * that allows the user to play the game. The provided VirtualController will be
     * handled by the ServerHandler (RMIServerHandler) and used to send messages.
     *
     * @param controller a remove object that the player can use to play the game
     * @throws RemoteException if an error occurs during remote communication
     */
    @Override
    public void setController(VirtualController controller) throws RemoteException {
        ServerHandler serverHandler = Client.getInstance().getServerHandler();
        if (serverHandler instanceof RMIServerHandler)
            ((RMIServerHandler) serverHandler).setController(controller);
    }

    /**
     * Asynchronously sets the identifier of the local player.
     * The player identifier encapsulated into each outbound message in order
     * for the server to recognize the sender. The identifier is mandatory for most messages.
     *
     * @param playerIdentifier the playerIdentifier generated by the server for this client
     * @throws RemoteException if an error occurs during remote communication
     */
    @Override
    public void setPlayerIdentifier(String playerIdentifier) throws RemoteException {
        view.forwardMessage(new ConnectionConfirmationMessage(playerIdentifier));
    }

    /**
     * Asynchronously sets the starting card for the local player.
     *
     * @param card the StartCard object representing the player starting card.
     * @throws RemoteException if an error occurs during remote communication
     */
    @Override
    public void setStartingCard(StartCard card) throws RemoteException {
        view.forwardMessage(new StartCardUpdateMessage(card));
    }

    /**
     * Asynchronously sets the common goals for the game that is currently
     * being played by the local player.
     *
     * @param goals a list of Goal objects that represents the public goals for the current game.
     * @throws RemoteException if an error occurs during remote communication
     */
    @Override
    public void setCommonGoals(Goal[] goals) throws RemoteException {
        view.forwardMessage(new CommonGoalsUpdateMessage(goals));
    }

    /**
     * Asynchronously sets the list of available goals for the player to choose
     * in order to obtain the definitive private goal.
     *
     * @param goals a list of Goal object that represents the available private goals.
     * @throws RemoteException if an error occurs during remote communication
     */
    @Override
    public void setAvailablePrivateGoals(Goal[] goals) throws RemoteException {
        view.forwardMessage(new PrivateGoalUpdateMessage(goals));
    }

    /**
     * Asynchronously sets the local player's definitive goal.
     *
     * @param goal the Goal object representing the player definitive private Goal.
     * @throws RemoteException if an error occurs during remote communication
     */
    @Override
    public void setDefinitivePrivateGoal(Goal goal) throws RemoteException {
        view.forwardMessage(new PrivateGoalUpdateMessage(goal));
    }

    /**
     * Asynchronously sets one of the local player's cards (hand).
     *
     * @param playerNickname the nickname of the player whose board needs to be updated.
     * @param card           the PlayCard object representing the new card to put in the player's hand.
     * @param index the index of the player's hand that needs to be updated
     * @throws RemoteException if an error occurs during remote communication
     */
    @Override
    public void setPlayersCard(String playerNickname, PlayCard card, int index) throws RemoteException {
        view.forwardMessage(new PlayersHandUpdateMessage(playerNickname, card, index));
    }

    /**
     * Asynchronously sets one of the visible cards for the game that is currently
     * being played by the local player.
     *
     * @param card  the PlayCard object representing the new visible card.
     * @param index the index of the visible card to change.
     * @throws RemoteException if an error occurs during remote communication
     */
    @Override
    public void setVisibleCard(PlayCard card, int index) throws RemoteException {
        view.forwardMessage(new VisibleCardUpdateMessage(card, index));
    }

    /**
     * Asynchronously sets one of the deck's top card resource for the game that is
     * currently being played by the local player.
     *
     * @param resource the Resource object representing the resource on the back of the card on top of the deck.
     * @param index    the deckID that identify the deck that needs to be updated.
     * @throws RemoteException if an error occurs during remote communication
     */
    @Override
    public void setDeckTopResource(Resource resource, int index) throws RemoteException {
        view.forwardMessage(new DeckUpdateMessage(resource, index));
    }

    /**
     * Asynchronously places a card on a player's board.
     *
     * @param playerNickName the nickname of the player whose board needs to be updated.
     * @param cardSlot       the CardSlot that contains the card that was placed.
     * @param location      the location where the CardSlot needs to be placed
     * @throws RemoteException if an error occurs during remote communication
     */
    @Override
    public void placeCardOnPlayersBoard(String playerNickName, CardSlot cardSlot, CardLocation location) throws RemoteException {
        view.forwardMessage(new PlayersBoardUpdateMessage(playerNickName, cardSlot, location));
    }

    /**
     * Asynchronously updates the local list of available games.
     *
     * @param availableGames a set of integer, each integer represents the ID of an available game
     * @throws RemoteException if an error occurs during remote communication
     */
    @Override
    public void updateGameList(Set<String> availableGames) throws RemoteException {
        view.forwardMessage(new GameListMessage(availableGames));
    }

    /**
     * Asynchronously tells the view that a game was successfully joined.
     *
     * @param nickname the nickname that the clients chose when they joined the game.
     * @param savings  if the player is rejoining a game, this ClientGameSaving object contains all data that the player need
     * @throws RemoteException if an error occurs during remote communication
     */
    @Override
    public void confirmJoin(String nickname, ClientGameSaving savings) throws RemoteException {
        view.forwardMessage(new JoinConfirmationMessage(nickname, savings));
    }

    /**
     * Asynchronously updates the local list of players connected to the same game as the local player.
     *
     * @param nicknames the array of nicknames of the players in the game.
     * @param colors    the array of colors of the players in the game.
     * @throws RemoteException if an error occurs during remote communication
     */
    @Override
    public void updatePlayersList(String[] nicknames, PlayerColor[] colors) throws RemoteException {
        view.forwardMessage(new PlayersListUpdateMessage(nicknames, colors));
    }

    /**
     * Asynchronously tells the local View the current state of the game and the current turn (if the game has started)
     *
     * @param gameStatus  the current game phase
     * @param turnStatus  the current turn status (either DRAW or PLACE)
     * @param playersTurn the nickname of the player that needs to play.
     * @throws RemoteException if an error occurs during remote communication
     */
    @Override
    public void updateGameStatus(GameStatus gameStatus, TurnStatus turnStatus, String playersTurn) throws RemoteException {
        view.forwardMessage(new GameStatusUpdateMessage(gameStatus, turnStatus, playersTurn));
    }

    /**
     * Asynchronously report errors (usually caused directly by the player or the client).
     *
     * @param exception a RuntimeException containing the error that needs to be reported.
     * @throws RemoteException  if an error occurs during remote communication
     */
    @Override
    public void reportError(RuntimeException exception) throws RemoteException {
        view.forwardMessage(new ServerErrorMessage(exception));
    }

    /**
     * Asynchronously updates the scoreboard for the game the local player's playing.
     *
     * @param scoreBoard the updated scoreboard
     * @throws RemoteException if an error occurs during remote communication
     */
    @Override
    public void updateScore(ScoreBoard scoreBoard) throws RemoteException {
        view.forwardMessage(new ScoreUpdateMessage(scoreBoard));
    }

    /**
     * Allows to perform an asynchronous ping request/answer to the Client's View.
     *
     * @param isAnswer {@code true} if the server is answering to a previous ping message, {@code false} if the server is checking on the client.
     * @throws RemoteException if an error occurs during remote communication
     */
    @Override
    public void ping(boolean isAnswer) throws RemoteException {
        view.forwardMessage(new ServerToClientPingMessage(isAnswer));
    }

    /**
     * Allows to forward a chat message to the client's View.
     *
     * @param chatMessage the ChatMessage object that contains info about the message
     * @param isPrivate {@code true} if the message is private, {@code false} otherwise
     * @throws RemoteException  if an error occurs during remote communication
     */
    @Override
    public void sendChatMsg(ChatMessage chatMessage, boolean isPrivate) throws RemoteException {
        view.forwardMessage(new ServerChatMsgMessage(chatMessage, isPrivate));
    }
}
